---
layout: post
title: 理解CSS定时器函数
categories: css
---

全世界的人们请注意并准备好，在逐渐领会了非常有意思的CSS定时函数厚，你们一定会有令人兴奋的体验。

OK，这篇文章的主题可能还没有能让你热血沸腾，但撇开这些笑话，定时函数真的是CSS动画的一个隐藏的亮点，你或许会惊讶它所能做到的事情。


首先，让我们设定一下场景，确保我们都可以熟悉时间函数相关的使用场景。如前所述，在你使用CSS动画的时候，这个功能可以应用了，
这些动画包括CSS transitions和基于keyframe的动画。那么，它究竟是什么，又是做什么的呢？

###The CSS Timing Function Explained

它是基于animation的一个不太常见的属性，而它的很多同类属性意思是显而易见的。虽然如此，它的主旨是让你可以控制和改变动画的加速-也就是说，它定义了在设定的持续时间里在哪里
加速和减速。

尽管它不影响动画的持续时间，它对用户对动画的动或慢的感知有深刻的影响。如果你还没有被教导了解它的实际目的，那就跟紧我，因为 timing-function属性被定义显示的有趣多了。

注意：事实上，没有名家”timing-function“的属性，，当我引用这个属性的时候，我实际上是指transition-timing-function 和 the animation-timing-function 属性。


在继续之前，让我们先熟悉一下语法和在CSS中定义动画的过程。方便起见，我们使用CSS transition作为例子。我们会以所有transition属性开始：

	div {
	   transition-property: background;
	   transition-duration: 1s;
	   transition-delay: .5s;
	   transition-timing-function: linear;
	}

	/* This could, of course, be shortened to: */
	div {
	   transition: background 1s .5s linear;
	}
定义transition的缩写非常宽松，对顺序的唯一要求是delay属性必须要在duration属性之后声明（但不一定要紧跟在后面）。而且，为了让代码可以运行，transition-duration是唯一要求的属性
因为其它属性的默认值在大多数时候都足够了，你的transition很少需要比下面的片段更多的代码：

	div {
	   transition: 1s;
	}

	/* This is the same as saying: */
	div {
	   transition: all 1s 0s ease;
	}
	
但这有点无趣。尽管默认值对于标准的hover事件等等常常是足够了，但是如果需要处理一些更充实的东东，那么定时函数将是微调动画的重要的工具。

###揭开面纱

你们也许还没有看过定时函数属性的所有的值，有5个：ease (默认值), ease-in, ease-out, ease-in-out and linear。然后，这些值只是定义贝塞尔曲线的的一些缩写。

那是什么？

或许你不熟悉这个术语，但我打赌你实际上已经看到过贝塞尔曲线了-如果你用过图片编辑软件，那么你或许甚至创建过！
是的，当你用钢笔或者路径工具创建一个好看的圆滑的曲线时，那么你就在画贝塞尔曲线！无论如何，本节的重点，贝塞尔曲线是定时函数背后的魔术；它基本上描述了图片上的加速模式。

如果你像我一样，在第一次看到想这个得贝塞尔曲线的时候，那么你或许想知道图像上的4个点究竟是如何形成曲线的。我没办法几句话就讲清楚，还好，我有一个特别棒的gif图来帮我演示。

因为曲线是由4个点形成的，我们称之为”cubic“贝塞尔曲线，与“quadratic” （3个点）或者 ”quartic“（5个点）曲线相反。

###介绍cubic-bezier() 函数

那么，这是让事情变得有趣的地方，当我揭开你实际上可以通过函数cubic-bezier(来访问这个曲线，只需简单的用在替换定时器函数属性值的关键字。
我能理解你需要点点时间来消化你的兴奋。。。

使用cubic-bezier()函数，你可以操作以你期望的任何方式操作贝塞尔曲线，为你的动画创造完全定制的加速模式！
因此，让我们看看这个函数是如何工作的，它怎样让你可以创建自己的贝塞尔曲线。

首先，我们知道贝塞尔曲线是由4个点构成，分别称作点0，点1，点2和点3。另外一个需要注意的重要的事情是第一个和最后一个点已经在图上定义好了，点0总是位于0,0（左下)，点3总是位于1,1(右上).

 
所以就只剩下2个点在图上绘图，你可以使用cubic-bezier()函数来完成。那个函数需要4个参数，前两个参数是点1的x和y坐标，后两个是点2的x和y坐标。

  transition-timing-function: cubic-bezier(x, y, x, y);
  

  为了让你属性这个预发，还有如何用它创建曲线和对动画的物理效果，我会带你学习5个定时函数关键字，和他们对应的cubic-bezier()值，还有动画的效果。
  
#### EASE-IN-OUT
  我们以ease-in-out开始，因为曲线背后的逻辑和它是如何应用到动画上的或许是最容易理解的。
	/* The cubic-bezier() equivalent of the ease-in-out keyword */
	transition-timing-function: cubic-bezier(.42, 0, .58, 1);

  可以看到点1位于x轴上0.42，y轴上是0，而点2位于x轴0.58y轴1.结果是一个非常对策的贝塞尔曲线，意味着动画会加速到全速，然后用相同的速率减速，这也是关键字名字的由来。
  
####EASE


关键字ease是CSS定时函数的默认值，实际和之前的很像，尽管在减速之前，加速的速率更快。

/* The ease keyword and its cubic-bezier() equivalent */
transition-timing-function: cubic-bezier(.25, .1, .25, 1);
  

  你可以看见曲线开始时的尖锐的坡度，而结束点很长，这直接转换成动画的定时函数的物理效果。不要忘记看看之前的demo.
  
  
 ###EASE-IN AND EASE-OUT
 
不奇怪，ease-in和ease-out是正好相反的关键字。ease-in一直加速然后保持全速到一直最后，而后面那个关键字立刻达到全速然后减速到最后。我们之前看到的ease-in-out是这两个曲线的混合。

	/* The ease-in keyword and its cubic-bezier() equivalent */
	transition-timing-function: cubic-bezier(.42, 0, 1, 1);

	/* The ease-out keyword and its cubic-bezier() equivalent */
	transition-timing-function: cubic-bezier(0, 0, .58, 1);
	
###LINEAR

最好的这个关键字根本就不是曲线，正如名字暗示的那样，linear定时函数值在整个动画过程中维持同样的速度，这意味着导致贝塞尔曲线会只是一个直线。在图上没有变化的加速模式来描述。
/* The linear keyword and its cubic-bezier() equivalent */
transition-timing-function: cubic-bezier(0, 0, 1, 1);

如果你看看之前的demo，你会发现尽管所有demo有一样的持续时间，一些动画似乎比另外一些慢。为什么呢？以easeinout为例子，我们知道它开始和结束的时候速度比较慢，意味着需要以
更快的速率通过动画的中间部分。这有效的确保了我们感知到实际的动画更短更快，而比如说，lieaner动画似乎更长。

###使用cubic-bezier()函数创建定制的加速模式

我们已经看过了关键字是如何与响应的贝塞尔曲线对应的，也看过了它对动画的影响。现在让我们看看如何使用cubic-bezier()函数创建定制的加速模式。



你现在应该可以在图上使用点1和点2绘制贝塞尔曲线，并且对它如何影响动画有一个一个比较深刻的影响了，但是如果让你在图上绘制不能看见的点，明显快就会感到单调无聊。


幸运的是，我们有像Lea Verou存在，他们似乎不会休息除非CSS发展再也不能简单了。Lea 已经开发了一个被恰当的命令为Cubic Bézier，基本上是一个创建完全定制的贝塞尔曲线的演习场。
并可以用他们和预定义的关键字比较。这对你而言意味着，再也不用武力的编辑贝塞尔函数里的数字了，你只需要访问 Cubic Bezier ，调整曲线知道获得你期望的效果。非常方便。


缩写的关键字是你开始定时函数的最佳选择，但是他们之前的区别常常是很小的。只有当你开始创建定制的贝塞尔曲线的时候，你才会意识到定时函数对动画巨大的影响。


只需要看看下面的例子展示的动画的巨大的不同，尽快他们所有都有几乎一样的持续时间。

我们看看第一个例子，理解产生这样不同的效果的原因
/* cubic-bezier() values for first example from preceding demo page */
transition-timing-function: cubic-bezier(.1, .9, .9, .1);

这个定时函数和默认的关键字主要的不同是沿着Y轴贝塞尔曲线陡峭的斜坡。这意味着动画是一阵阵的前进，中间有一个长的慢慢的暂停（曲线平坦）。这种模式
与我们习惯的定时器关键字形成鲜明对比，后者采用了了相反的措施，在开始或结束进入加速减速期，而不是在中间。

###让贝塞尔曲线富有创意

是的，它是真的：贝塞尔曲线甚至可以更加有趣！谁有想到过吗? 范围会变的很宽，随着揭示x轴限制在0-1，而y轴能在下边扩展，超越典型了0-1返回。


递增规模正是你认为的那样，底端(0)标记了动画的开始，顶端（1）标记了动画的结束。典型的，贝塞尔曲线总是验证y轴一可变的强度朝北运动知道它到达了动画的终点。
无论如何，把点1和点2凡在0-1之外的返回可以让曲线沿着y轴折回，这实际上会导致动画的相反运动！像之前一样，理解这个得最好方式是通过看图。


Conversely, you could place this backward motion at the beginning of the animation and also make
 it temporarily run past its intended finishing point. Think of it like taking a couple of steps back to get
 a running start; then, at the end, your momentum carries you past your destination, causing you to take a couple 
 of steps back to ensure that you arrive at the intended destination. 
Look at the working example to really understand what we’re talking about here. 
In addition, the Bézier curve that produces this effect can be seen below.

相反的，你可以把这个向后的运动放在动画的开始，也可以使它临时的超出目的结束点。想想，它需要几步回到起点，然后终点，
你的动力载着你超过了终点，到时你需要一些步子回来确保你到达目的地。

看看运行中的例子来真正理解我们在这里讨论的。此外，能产生效果的贝塞尔曲线如下所示：

你现在应该对于在0-1范围之外的贝塞尔值如何影响动画有一个比较好的了解了。我们可以看看整天移动箱子，但是让我们用一个例子来结束本节，清晰的演示创造性的定时函数的类型。


那是对的：我们正在做一个浮动的气球动画！。。。什么》你没有想到总是用CSS来完成？
 
 动画的主体是点击"add helium"，因此气球浮动到顶上，然后在贴住顶部之前会做一点跳动，就像它自然做的。使用在0-1之外的值的cubic-bezier()函数让我们可以创建
 跳动，最终帮助产生真实的效果。下面的片段显示了用在cubic-bezier()函数中的坐标，产生的贝塞尔曲线显示如下：

	/* The cubic-bezier() values for the bouncing balloon */
	transition-timing-function: cubic-bezier(.65, 1.95, .03, .32);

这个例子特别解释了曲线如何转换成最终的动画因为 它几乎完美的反映了动画。首先，你可以看到曲线从y轴的开始在直线上遍历到最后，表明气球以常速从起点动画的起点运动到终点。
然后与气球相似的，the curve bounces off the tip of the scale and goes into reverse before returning steadily and gradually to the top. 都非常直观！


如果你已经掌握了曲线和操作它的技能来完成你的想法，你已经成功了。

###定时函数和基于Keyframe的CSS动画



在我们继续之前需要注意的最后一点是在应用到CSS keyframe动画时定时函数如何表现。这些概念都和我们之前介绍的例子中的transition例子是一致的。
但是有一个例外需要意识到：在你应用定时函数到keyframs的时候，每帧执行，而不是作为一个整体。


简而言之，如果弄你有4帧把让一个盒子在一个矩形的4个角移动，你应用我们之前介绍的“bouncing”定时函数，那么这4个移动的每一个都会经历跳动，而不是整个动画。


注意如果100%的keyframe没有定义，那么元素会只是简单的回到它原来的样式，在这个例子里是期望的行为。从这个demo里，很明显的看到，定时函数被应用到这4真keyframe的每一帧
因为他们每一个都在容器里跳动。


如果你需要某个keyframe采用与其他不同的定时函数，直接应用单独的定时函数值就可以了，如下所示。

###介绍step()定时函数


你认为你已经完全了解了定时函数了吗？哈哈，我告诉过你CSS定时函数有许多比预定义的东东。

这一节，我们把曲线换成直接，我们会探索“stepping functions”的概念，通过“step()”函数来获得。


steps()函数不仅仅是一个好的工具，而且在工具箱里非常有用。让可以让你把动画分解成步骤，而不是通常我们习惯的渐变动画。例如，如果我们想做一个动画，把一个矩形在4s
内用4步移动400px到右边，那么矩形会没一秒跳100px，而不是连续的移动。我们看看这个例子需要的语法，这应该是绝对是一个微风，如果我们已经处理了贝塞尔曲线的复杂。


就想你看到的，非常简单，只需要声明动画分解的步骤数-但是要记住这个数字必须是正的，因此没有负数或者小树。无论如何，第二个可选的参数为你提供一点点更多的控制。
它可能的参数值是start和end，后面这个是默认值。

	transition-timing-function: steps(4, start);
	transition-timing-function: steps(4, end);
	

start值会在每一步的开始运行动画，而结束值会在每一步的末尾运行动画。用前面"moveing box"为例，下面的图片解释了两者的不同。


你可以看到，start值，只要触发动画就开始，而end值，会在第一部的末尾开始(在此例中，在本触发后1s)


只是确保以下概述是真的理解了，有两个steps()预定义的关键字：step-start和step-end.前面的等于steps(1, start)，后面的等于steps(1, end).


###创造性的Stepping 函数使用案例


好吧，或许你觉得没有太多的需要一步一步的移动盒子。但是许多其他的很酷的例子。例如，如果你有卡通的sprites，那么你可使用这个技术一帧一帧的来播放，只需要使用一点CSS属性！
我们来看一下demo和使它工作的代码。

div {
   width: 125px;
   height: 150px;
   background: url(images/sprite.jpg) left;
   transition: 2s steps(16);
   /* The number of steps = the number of frames in the cartoon */
}

div:target {
   background-position: -2000px 0;
}

首先，我们有一个小的矩形盒子(125px宽)，它有一个背景图(2000px 宽)，包含16帧。这个背景图刚开始与盒子的左边对齐，因此我们现在
需要做的是把背景图一直移到左边，因此所有16帧都可以通过小的矩形窗口。使用这个普通的动画，当背景图向左边移动的时候，那些帧会滑进滑出。而且，使用
steps()函数，背景图可以在16步内移动到左边，确保每帧snaps in and out of view。就想我们期望的。你可以只是用CSStransition，就完成一个基本的卡通。


我发现的steps()的另外一个创造性用法来自Lea Verou ，他想了一个特别聪明的类型动画，我会为你分解。


首先，你需要一些文本，然后，不幸的是，你需要知道你会使用多少字符，因为你需要在CSS里使用这个数字。另外一个要求是字体不行是单空格的，因此所有的字符是等宽的。

	<p>smashingmag</p>

	.text {
	   width: 6.6em;
	   width: 11ch; /* Number of characters */
	   border-right: .1em solid;
	   font: 5em monospace;
	}


我们用的文本有11个字符。在CSS单位ch的帮助下，我们实际上可以使用这个数字来定义段落的宽度，尽管我们应该设定一个浏览器的回退宽度，万一浏览器不支持这个单位。段落然后
在有伴设置一个黑色的边界，这个会变成cursor。现在万事俱备，我们只需要给他做动画，非常简单了。

Two separate animations are required: one for the cursor and one for the typing. To achieve the former, 
all we need to do is make the black border blink, which couldn’t be simpler.

需要两个单独的动画：一个是cusor，另外一个是打字。为了获取前面的，我们需要做的是做一个黑色的边界闪动，这非常简单。

	@keyframes cursor {
	   50% {
		 border-color: transparent;
	   }
	}

	.text {
	   /* existing styles */
	   animation: cursor 1s step-end infinite;
	}

	
	和计划的一样，黑色的边框只是简单的在黑色好透明之间切换，然后不断的循环。这是steps()函数重要的地方，因为，如果没有他，cursor会只是渐隐渐现，而不是闪烁
	
	最后，打印动画一样的简单。需要做的就是减少段落的宽度到0，然后在11步里(字符的数量)动画回到完整宽度。

	
	单个keyframe准备好了后，文本会一次8s显示自己，而黑色右边界会不断的闪动。技术非常简单，非常有效。
	
	Just to add to this excellent use of the steps() function by Lea Verou, 
	reversing the effect and making the text appear to be deleted is also a cinch. To achieve this, 
	just change the keyframe keyword so that it reads to rather than from, and then add an animation-fill-mode parameter 
	of forwards to the set of animation rules. This will ensure that once the text “deletes” (i.e. when the animation has finished), 
	the text will remain deleted. Look at the demo below to see this in action.
	
	只要补充一下steps()函数的这个很棒例子，颠倒这个效果，让文本时候正在被删除。为了获得这个效果，只需要改变keyframe关键字，因此他从